# InnoDB 스토리지 엔진 아키텍처 
![img.png](img.png)

- 스토리지 엔진 중 거의 유일하게 레코드 기반 잠금 제공 
- 높은 동시성 처리 가능
- 안정적이며 성능이 뛰어남 

<br>

## 프라이머리 키에 의한 클러스터링 
- InnoDB의 모든 테이블은 프라이머리 키를 기준으로 클러스터링되어 저장 됨 
  - 프라이머리 키 값 순서대로 디스크에 저장된다는 뜻 
  - 모든 세컨더리 인덱스 -> 레코드 주소 대신 프라이머리 키의 값을 논리 주소로 사용 
- 프라이머리 키가 클러스터링 인덱스 -> PK를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있음 
- 쿼리 실행 계획에서 PK는 다른 보조 인덱스에 비해 기본적으로 비중이 높게 설정됨 
  - 쿼리 실행 계획에서 다른 보조 인덱스보다 PK가 선택될 확률이 높음 


- MyISAM : 클러스터링 키 지원 X 
  - PK와 세컨더리 인덱스가 구조적으로 차이가 없음 
  - PK == 유니크 제약을 가진 세컨더리 인덱스 
  - PK를 포함한 모든 인덱스가 물리적인 레코드 주소 값(ROWID)을 가짐

<br>

## 외래 키 지원 
- InnoDB 스토리지 엔진 레벨에서 지원하는 기능 
- FK는 데이터베이스 서버 운영의 불편함 때문에 서비스용 DB에선 생성하지 않는 경우도 자주 있음 
- InnoDB의 외래 키
  - 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성 필요 
  - 변경 시 부모 or 자식 테이블에 데이터가 있는지 체크하는 작업 필요 -> 락이 여러 테이블로 전파됨 
  - 그로 인해 데드락이 발생할 수 있음 -> 개발 시 FK 존재에 주의하는 것이 좋음 

- `foreign_key_checks` 시스템 변수
  - global, session 모두 설정 가능 -> 주의해야 함 
  - 반드시 현재 작업을 실행하는 세션에만 적용하자 
  - 작업 완료 후에는 반드시 세션을 종료하거나 해당 기능을 활성화 시켜주자 

<br>

## MVCC(Multi Version Concurrency Control)
- 레코드 레벨 트랜잭션을 지원하는 DBMS가 제공하는 기능 
- 락을 사용하지 않는 일관된 읽기를 제공함 
- InnoDB는 **언두 로그(Undo log)** 를 이용해서 이 기능 구현 
  - Multi version : 하나의 레코드에 대해 여러 개의 버전이 동시에 관리됨

### data를 insert 후 update 할 때
![img_1.png](img_1.png)

- insert 문이 실행되면 DB 상태는 위와 같이 변경된다.
  - InnoDB 버퍼 풀에 데이터 존재
  - 데이터 파일(디스크)에 데이터 쓰기


`update member set m_area='경기' where m_id=12;`
![img_2.png](img_2.png)

- update 문이 실행되면 위와 같이 변경된다.
  - `m_area`의 변경 전 값만 언두 로그로 복사한다. (InnoDB 버퍼 풀은 즉시 새로운 데이터로 변경된다.)
  - InnoDB 버퍼 풀의 변경 내용은, InnoDB 스토리지 엔진의 백그라운드 스레드에 의해 기록된다.
    - InnoDB 버퍼 풀의 변경 내용이 디스크의 데이터 파일에 기록됐는지 여부는 시점에 따라 다르다 
    - 즉, 체크포인트나 Write 스레드에 의해 새로운 값으로 업데이트돼 있을 수도 있고 아닐 수도 있음
    - 보통은 InnoDB가 ACID를 보장하기 때문에 InnoDB 버퍼 풀과 데이터 파일은 동일한 상태로 가정해도 됨 


아직 커밋이나 롤백이 되지 않은 상태에서, 다음과 같은 쿼리로 작업 중인 레코드를 조회하면 어디의 데이터를 조회할까? 
`select * from member where m_id=12;`
- 서버의 `transaction_isolation`시스템 변수에 설정된 격리 수준에 따라 다르다!
- `READ_UNCOMMITED` : InnoDB 버퍼 풀이 현재 가지고 있는 변경된 데이터를 읽어서 반환. (커밋/롤백이 되지 않았음에도)
- `READ_COMMITED`, `REPEATABLE_READ`, `SERIALIZABLE` 
  - 아직 커밋되지 않았기 때문에 InnoDB 버퍼 풀이나 데이터 파일에 있는 내용 대신, **변경되기 이전의 내용을 보관하고 있는 언두 영역의 데이터**를 반환한다.


위와 같은 과정을 DBMS에서는 `MVCC`라고 표현한다.
- 즉, 하나의 레코드에 대해 2개의 버전이 유지되고, 필요에 따라 어느 데이터가 보여지는지 여러 가지 상황에 따라 달라지는 구조임.
- 관리해야 하는 예전 버전 데이터는 무한히 많아질 수 있음 


커밋이되었을 때는 InnoDB는 더이상의 변경 작업 없이 지금의 상태를 영구적인 데이터로 만든다.
- 하지만 롤백이 되었다면 InnoDB는 언두 영역에 있는 백업된 데이터를 InnoDB 버퍼 풀로 다시 복구하고, 언두 영역의 내용을 삭제한다.
- 언두 영역 데이터는 커밋 시 항상 바로 삭제되는 것은 아니며, 이 언두 영역을 필요로 하는 트랜잭션이 없을 때 삭제된다.

<br>

## 잠금 없는 일관된 읽기(Non-Locking Consistent Read)
InnoDB 스토리지 엔진은 MVCC 기술을 이용해 락을 걸지 않고 읽기 작업을 수행한다. 
- 락을 걸지 않기 때문에, 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고 읽기 작업 가능 
- `serializable`격리 수준이 아니라면, 순수한 읽기(only select)작업은 다른 트랜잭션의 변경 작업과 관계 없이 항상 락을 대기하지 않고 바로 실행 됨 


<img src="img_3.png" width="300">

- 특정 사용자가 update 실행 중임 + 아직 커밋 안했을 경우 
  - 해당 변경 트랜잭션이 다른 사용자의 select 작업을 방해하지 않음 
  - 변경되기 전의 데이터를 읽기 위해 언두 로그를 사용 


- 오랜 시간 활성 상태인 트랜잭션 -> 서버가 너무 느려지거나 문제가 발생 
  - 일관된 읽기를 위해 언두 로그를 삭제하지 못하고 계속 유지해야 하기 때문에 발생 
  - 트랜잭션이 시작됐다면 가능한 한 빨리 롤백/커밋을 통해 트랜잭션을 완료하자

<br>

## 자동 데드락 감지 
- 락 대기 목록 그래프(Wait-for List)
  - 락이 교착 상태에 빠지지 않았는지 체크
- InnoDB 스토리지 엔진은 데드락 감지 스레드를 갖고 있다.
  - 해당 스레드가 주기적으로 락 대기 그래프를 검사해 데드락에 빠진 트랜잭션들을 찾아서 그 중 하나를 강제 종료함 
  - 강제 종료 기준 -> 트랜잭션의 언두 로그 양 -> 언두 로그 레코드를 더 적게 가진 트랜잭션이 롤백의 대상 
  - 언두 레코드를 적게 가졌다 == 롤백을 해도 언두 처리를 해야할 내용이 적다 
    - 따라서 트랜잭션 강제 롤백으로 인한 서버 부하도 덜 유발함 


- InnoDB 스토리지 엔진은 상위 레이어인 MySQL 엔진에서 관리되는 테이블 락은 볼 수 없음 
  - 데드락 감지가 불확실할 수 있음 
  - `innodb_table_locks`를 활성화 하면 스토리지 엔진 내부 레코드 락 + 테이블 레벨의 락까지 감지할 수 있게 됨 
  - 특별한 이유가 없다면 해당 변수는 활성화 하자 


- 일반적인 서비스 상에서
  - 데드락 감지 스레드가 트랜잭션 락 목록을 검사해서 데드락을 찾아내는 작업은 크게 부담되지 않음
- 동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 락의 개수가 많아지면, 데드락 감지 스레드가 느려짐 
  - 데드락 감지 스레드는 락 상태가 변경되지 않도록, 락 목록이 저장된 리스트(락 테이블)에 새로운 락을 걸고 데드락 스레드를 찾는다.
  - 데드락 감지 스레드가 느려지면, 서비스 쿼리를 처리 중인 스레드는 더는 작업을 진행하지 못하고 대기하면서 서비스에 악영향을 미침 
  - 동시 처리 스레드가 많은 경우, 데드락 감지 스레드는 더 많은 CPU 자원을 소모할 수도 있음

### 문제 해결 
- `innodb_deadlock_detect` 시스템 변수 제공 
  - 이를 OFF로 설정하면 데드락 감지 스레드가 더이상 작동하지 않음 
    - InnoDB 스토리지 엔진 내부에서 2개 이상의 트랜잭션이 상대방이 가진 락을 요구하는 상황(데드락 상황)이 발생해도 중재자가 없기 때문에 무한정 대기하게 됨 
- `innodb_lock_wait_timeout` 시스템 변수 활성화
  - 데드락 상황에서 일정 시간이 지나면 자동으로 요청 실패 -> 에러 메시지 반환 
  - 초 단위 설정 가능
  - 설정 시간 내에 락을 획득하지 못하면 쿼리는 실패하고 에러 반환 
  - 데드락 감지 스레드가 부담되어 innodb_deadlock_detect를 비활성화 했다면 시간 설정을 기본값인 50초보다 훨씬 낮은시간으로 변경해서 사용할 것을 권고 


> 만약 PK 또는 세컨더리 인덱스 기반으로 매우 높은 동시성 처리를 요구하는 서비스가 있다면 `innodb_deadlock_detect`를 비활성화 해서 성능 비교를 해보는 것도 좋을것임


<br>

## 자동화된 장애 복구 
InnoDB에는 손실이나 장애로부터 데이터를 보호하기 위한 여러 가지 매커니즘이 탑재돼있음.
- 이를 이용해 서버가 시작될 때 완료되지 못한 트랜잭션이나, 디스크에 일부만 기록된(Partial write) 데이터 페이지 등에 대한 일련의 복구 작업이 자동으로 진행 됨 

InnoDB 스토리지 엔진은 데이터 파일이 손상되거나, 서버가 시작되지 못하는 경우는 거의 발생하지 않음 
- 하지만, 서버와 무관하게 디스크나 서버 하드웨어 이슈로 스토리지 엔진이 자동으로 복구를 못하는 경우도 발생할 수 있음 
- InnoDB 데이터 파일은 기본적으로 MySQL 서버가 시작될 때 항상 자동 복구를 수행함 
- 자동으로 복구될 수 없는 손상이 있을 경우 자동 복구를 멈추고 서버가 종료됨 


### 해결 
- 서버 설정 파일에 `innodb_force_recovery`시스템 변수 설정 후 서버 시작 
  - 해당 변수는 InnoDB 스토리지 엔진이 데이터 파일이나 로그 파일의 손상 여부 검사 과정을 선별적으로 진행할 수 있게 함 
  - 로그 파일이 손상된 경우 -> 6으로 설정하고 서버 기동
  - 테이블 데이터 파일 손상 -> 1로 설정하고 서버 기동 
  - 어떤 부분이 문제인지 알 수 없다면 1~6까지 변경하면서 재시작 해봄 (값이 커질수록 심각한 상황)


- MySQL 서버가 기동된 후 InnoDB 테이블이 인식된다면, `mysqldump`를 이용해 데이터를 가능한 만큼 백업하고 해당 데이터로 서버의 DB와 테이블을 다시 생성하는 것이 좋음 

<br>

#### 값이 1인 경우
- SRV_FORCE_IGNORE_CORRUPT
- 테이블스페이스의 데이터나 인덱스 페이지 손상이 발견돼도 무시하고 서버 시작 
- `Database page corruption on disk or a failed` 메시지가 출력 될 때 대부분 이 경우임
- `mysqldump` 프로그램이나 `select into outfile` 명령을 이용해 덤프 후 db를 다시 구축하는 것이 좋음

<br>

#### 값이 2인 경우
- SRV_FORCE_NO_BACKGROUND
- InnoDB는 쿼리 처리를 위해 여러 종류의 백그라운드 스레드를 동시에 사용함 
- 해당 복구 모드에서는 백그라운드 스레드 가운데 메인 스레드를 시작하지 않은 채 서버를 시작함 
- 트랜잭션의 롤백을 위한 언두 데이터 관리 -> 트랜잭션이 커밋되어 불필요한 언두 데이터는 메인 스레드에 의해 주기적으로 삭제(Undo perge)됨 
- InnoDB의 메인 스레드가 언두 데이터를 삭제하는 과정에서 장애가 발생한다면 해당 모드로 복구하면 됨 


<br>

#### 값이 3인 경우 
- SRV_FORCE_NO_TRX_UNDO
- InnoDB는 트랜잭션 실행 시, 롤백에 대비해 변경 전 데이터를 언두 영역에 기록함 
- 일반적으로 서버 재시작 시 언두 영역 데이터를 먼저 데이터 파일에 적용하고, 그 다음 리두 로그의 내용을 다시 덮어 써서 장애 시점의 데이터 상태를 만들어냄 
- 정상적인 서버 시작에서는 최종적으로 커밋되지 않은 트랜잭션은 롤백 수행 
  - 3단계의 복구 모드에서는 커밋되지 않은 트랜잭션 작업을 롤백하지 않고 그대로 둔다.
- 즉, 커밋되지 않고 종료된 트랜잭션이 계속 그 상태로 남아있도록 MySQL 서버를 시작하는 모드 
- `mysqldump`로 데이터를 백업하고 db를 재구축하는게 좋음 


<br>

#### 값이 4인 경우 
- SRV_FORCE_NO_IBUF_MERGE
- 데이터 변경으로 인한 인덱스 변경 작업을 상황에 따라 즉시 처리 or 인서트 버퍼에 저장해두고 나중에 처리 함 
- 인서트 버퍼에 기록된 내용은 언제 데이터 파일에 병합될지 알 수 없음
- 서버를 종료해도 병합되지 않을 수 있음 
  - 만약 서버가 재시작되면서 인서트 버퍼의 손상을 감지하면 InnoDB는 에러를 발생시키고 MySQL 서버는 시작하지 못함 
- 4단계 복구 모드에서는 InnoDB 스토리지 엔진이 인서트 버퍼의 내용을 무시하고 강제로 MySQL이 시작되게 함 
- 인서트 버퍼는 실제 데이터 관련 부분이 아닌, 인덱스 관련 부분임 -> 테이블 덤프 후 다시 db를 구축하면 데이터 손실 없이 복구 가능 


<br>

#### 값이 5인 경우
- SRV_FORCE_NO_UNDO_LOG_SCAN
- 서버가 장애나 정상적으로 종료되는 시점에 진행중인 트랜잭션이 있는 경우, 단순히 그 커넥션을 강제로 끊고 별도의 정리 작업 없이 종료함 
  - 서버를 재시작하면 InnoDB 엔진은 언두 레코드를 이용해 DB 페이지를 복구하고, 리두 로그를 적용해 종료 시점이나 장애 발생 시점의 상태를 재현함 
  - InnoDB는 마지막으로 커밋되지 않은 트랜잭션에서 변경한 작업은 모두 롤백 처리함 
- 만약 InnoDB의 언두 로그를 사용할 수 없다면, 엔진의 에러로 인해 서버를 시작할 수 없게 됨 
- 5단계 복구 모드에서는 InnoDB 엔진이 언두 로그를 모두 무시하고 서버를 시작함 
- 이 모드로 시작할 경우, 서버가 종료되던 시점에 커밋되지 않았던 작업도 모두 커밋된 것처럼 처리 됨 -> 잘못된 데이터가 DB에 남음 
- `mysqldump`를 이용해 데이터 백업 및 DB 새로 구축 


<br>

#### 값이 6인 경우 
- SRV_FORCE_NO_LOG_REDO
- InnoDB 스토리지 엔진의 리두 로그가 손상되면 서버가 시작되지 못함
- 6단계 복구 모드로 시작하면 InnoDB 엔진은 리두 로그를 모두 무시한 채로 서버가 시작됨 
- 커밋이 됐다 하더라도, 리두 로그에만 기록되고 데이터 파일에 기록되지 않은 데이터는 모두 무시 
  - 마지막 체크 포인트 시점의 데이터만 남음
- 이 때는 기존 InnoDB의 리두 로그는 모두 삭제하거나 별도의 디렉터리에 백업하고 서버를 시작하는 것이 좋음 
- 서버가 시작되면서 리두 로그가 없으면 새로 생성하므로 별도로 파일을 만들 필요가 없음. 
- `mysqldump`를 이용해 모두 백업해서 서버를 새로 구축하는 것이 좋음 


위와 같이 진행헀음에도 서버가 시작되지 않으면, 백업을 이용해 재구축 하는 방법밖에 없음
- 백업이 있다면 마지막 백업으로 데이터베이스를 새로 구축하고, 바이너리 로그를 사용해 최대한 장애 시점까지의 데이터를 복구할 수도 있음 
- 풀 백업과 바이너리 로그로 복구하는 편이 데이터 손실이 더 적을 수 있음 
- 백업은 있지만 복제의 바이너리 로그가 없거나 손실됐다면 마지막 백업까지만 복구 가능 





