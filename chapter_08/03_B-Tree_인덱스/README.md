# B-Tree 인덱스
- Balanced Tree
- B+-Tree, B*-Tree ... 
- 원래 값을 변형시키지 않고(값의 앞부분만 잘라서 관리하기는 함)
- 인덱스 구조체 내에서는 항상 정렬된 상태로 유지함 


## 구조 및 특성 
### 구조 
![img_1.png](img_1.png)

- 최상위에 하나의 루트 노드가 존재 + 하위에 자식 노드가 붙어 있음 
  - 중간 노드는 브랜치 노드라고 부름 
  - 가장 하위는 리프 노드라고 부름
- 인덱스와 실제 데이터는 따로 관리 됨
  - 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 **주솟값**을 가지고 있음 

- 인덱스 키 : 모두 정렬
- 데이터 파일 레코드 : 임의의 순서
  - insert된 순서대로 저장되는 것이 아님 
  - 레코드 삭제로 빈 공간이 생기면 그 다음 insert는 삭제된 공간을 재활용 하도록 하기 때문 

> InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장되기 때문에, 기본적으로 프라이머리 키 순서로 정렬되어 저장 됨 

<br/><br/>

인덱스는 테이블의 키 칼럼만 가지고 있다.
  - 나머지 칼럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다.
  - 이를 위해 인덱스의 리프 노드는 데이터 파일에 저장된 레코드 주소를 가짐


#### MyISAM 리프 노드 + 테이블 데이터 레코드
![img_2.png](img_2.png)
- 레코드 주소
  - 레코드가 테이블에 insert된 순번 혹은 데이터 파일 내의 위치(offset)
- 세컨더리 인덱스가 물리적인 주소를 가짐

#### InnoDB 리프 노드 + 테이블 데이터 레코드
![img_3.png](img_3.png)
- PK가 Row의 id 역할을 함 (ROWID)
- PK를 주소처럼 사용 -> 논리적인 주소
- 데이터 파일을 바로 찾아가지 못함 
  - 인덱스에 저장돼 있는 PK 값을 이용해 PK 인덱스를 한번 더 검색한 후, PK 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽음
  - 즉, 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 PK를 저장하고 있는 B-Tree를 다시한번 더 검색해야 함 


### B-Tree 인덱스 키 추가 및 삭제 
- 레코드를 저장하거나 변경하는 경우 인덱스 키 추가/삭제 작업이 발생함 
- 어떻게 처리되는지 알아야 쿼리 성능 예측 가능 

#### 인덱스 키 추가 
- B-Tree에 새로운 키 값이 저장될 때 
  - 저장될 키 값을 이용해 적절한 위치를 검색 
  - 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 리프 노드에 저장 
- 리프노드가 꽉 찬 경우 
  - 리프 노드 분리(Split)해야 함 -> 상위 브랜치 노드까지 처리 범위가 넓어짐 
  - 이러한 작업으로 인해 B-Tree는 상대적으로 쓰기 작업(새로운 키 추가)에 비용이 많이 듦 
- 대략적 계산 방법
  - 레코드를 추가하는 비용을 1이라고 가정할 경우, 인덱스에 키를 추가하는 작업 비용은 1.5 정도로 예측할 수 있음 
  - 테이블에 인덱스가 3개 있다면, 인덱스가 하나도 없는 경우 작업 비용이 1이고, 3개인 경우네는 5.5(1.5 * 3 + 1) 정도로 예측함 
  - **비용의 대부분이 CPU, 메모리에서 처리하는 시간이 아니라 디스크로부터 인덱스 페이지를 읽고 쓰기를 해야해서 걸리는 시간임**<br/><br/>


- MyISAM, Memory -> 새로운 키 값을 즉시 인덱스에 변경 
- InnoDB -> 필요 시 인덱스 키 추가 작업을 지연시켜 나중에 처리 
  - PK, 유니크 인덱스는 중복 체크 필요 -> 즉시 추가/삭제 함 <br/><br/>

#### 인덱스 키 삭제
- 해당 키 값이 저장된 리프 노드를 찾은 후 삭제 마크 수행 
- 삭제 마킹된 인덱스 키 공간 -> 방치 or 재활용 
- 삭제로 인한 마킹 작업 또한 디스크 쓰기 필요 -> 디스크 입출력 필요 
  - InnoDB에서는 버퍼링 + 지연 처리 가능 
  - 처리가 지연된 인덱스 키 삭제 -> 사용자에게 특별한 악영향 없이 서버가 내부적으로 처리<br/><br/> 

#### 인덱스 키 변경 
- 인덱스 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정 됨 
- 키가 변경되는 경우, 단순히 인덱스 상의 키 값만 변경하는 것은 불가능함 
- 변경 작업
  - 키 값 삭제 
  - 다시 새로운 키 값 추가 
- InnoDB는 체인지 버퍼를 활용해 지연 처리 가능 <br/><br/>


#### 인덱스 키 검색 
- 트리 탐색 
  - 루트 노드 -> 브랜치 노드 -> 리프 노드 이동하면서 비교 작업 수행
  - select 뿐만 아니라 update, delete를 처리하기 위해 해당 레코드를 먼저 검색해야 할 경우에도 사용 
- B-Tree 인덱스를 이용한 검색은 **100% 일치 혹은 값의 앞부분만 일치하는 경우**에 사용 가능
- 인덱스 키 값에 변형이 가해진 후 비교되는 경우, 절대 B-Tree의 빠른 검색 기능을 사용할 수 없음
  - 이미 변형된 값은 인덱스에 존재하는 값이 아님 
- InnoDB 스토리지 엔진에서의 인덱스
  - 테이블에서 지원하는 레코드 잠금이나 넥스트 키락(갭락)이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현돼 있음 
  - update, delete 문장이 실행될 때 테이블에 적절히 사용할 수 있는 인덱스가 없는 경우 불필요하게 많은 레코드를 잠금 
  - 테이블의 모든 레코드를 잠글 수도 있음 
  - InnoDB 스토리지 엔진에서는 그만큼 인덱스 설계가 중요하고 많은 부분에 영향을 미침<br/><br/>


## B-Tree 인덱스 사용에 영향을 미치는 요소 
### 인덱스 키 값의 크기 
- 페이지/블록 : 디스크에 데이터를 저장하는 가장 기본 단위 
  - 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 됨
  - InnoDB 버퍼 풀에서 데이터를 버퍼링하는 기본 단위이기도 함
  - 인덱스도 결국은 페이지 단위로 관리 됨 <br/><br/>
- B-Tree는 자식 노드의 개수가 가변적인 구조임
  - 인덱스 페이지 크기와 키 값에 크기에 따라 자식노드 개수가 결정됨 

![img.png](img.png)
- 자식 노드 주소 : 여러 가지 복합적인 정보가 담긴 영역
- 위 그림의 경우 하나의 인덱스 페이지에 16 * 1024 / (16 + 12) = 585개 저장 가능 
- 자식 노드를 585개 가질 수 있는 B-Tree가 되는 것 


- 인덱스 키 값이 커지면 커질수록 
  - 디스크로부터 읽어야 하는 횟수가 증가한다 -> 느려짐 
  - 전체적인 인덱스 크기가 커진다 -> InnoDB 버퍼 풀에 캐시해둘 수 있는 레코드 수가 감소 -> 메모리 효율 감소<br/><br/>

### B-Tree 깊이
- 상당히 중요하지만 직접 제어 불가능
  - 값을 검색할 때, 몇 번이나 랜덤하게 디스크를 읽어야 하는지와 직결됨 
- 위 그림에서 B-Tree 깊이가 3인 경우 
  - 키가 16바이트 : 최대 2억 (585^3)개 정도의 키 값을 담음
  - 키가 32바이트 : 최대 5천만(372^3)개 정도의 키 값을 담음 
- 인덱스 키 값의 크기가 커질수록, 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어짐 
  - 같은 레코드 건수라 하더라도 B-Tree의 깊이가 깊어져서 디스크 읽기가 더 많이 필요하게 된다는 것을 의미 
> 인덱스 키 값의 크기는 가능하면 작게 만드는 것이 좋다!

<br/><br/>
### 선택도(기수성)
- 모든 인덱스 키 값 가운데 유니크한 값의 수 
  - 전체 인덱스 키 값이 100개인 경우, 유니크한 값의 수가 10개라면 -> 기수성은 10 
  - 중복 증가 -> 기수성 감소 -> 선택도 감소 
- 선택도가 높을 수록 검색 대상이 줄어들기 때문에 빠르게 처리 됨 
> 인덱스는 항상 검색에만 사용되는 것은 아니다.
> - 정렬이나 그루핑과 같은 작업을 위해 인덱스를 만드는 것이 훨씬 더 나은 경우도 많음 
> - 여러 가지 용도를 고려해 적절히 인덱스를 설계하자. 

<br/><br/>
### 인덱스를 이용한 읽기의 손익 분기점 
- 인덱스를 통해 레코드 1건을 읽는 것 
  - 테이블에서 직접 레코드 1건을 익는 것 보다 4~5배 정도 비용이 더 많이 드는 작업임
  - 즉, 인덱스를 통해 읽어야 할 레코드 건수가 전체 테이블 레코드의 20~25%를 넘어 서는 경우, 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 가려내는 (필터링) 방식으로 처리하는 것이 효율적임 
  - 이는 MySQL 옵티마이저가 판단함 

<br/><br/>
## B-Tree 인덱스를 통한 데이터 읽기 