# 인덱스
- 칼럼(혹은 칼럼들)의 값과 해당 레코드가 저장된 주소를 키-값 쌍으로 삼아 인덱스를 만든다.
- 칼럼의 값을 주어진 순서로 미리 정렬해서 보관함 
  - 데이터 파일은 저장된 순서대로 보관됨


- 데이터가 저장될 때 마다 항상 값을 정렬해야 함 
  - 저장하는 과정이 복잡하고 느림 (insert, update, delete 처리가 느려짐)
  - 이미 정렬돼 있어서 아주 빨리 원하는 값을 찾아올 수 있음 (select 처리가 매우 빨라짐)


- 인덱스는 데이터의 저장 성능을 희생하고, 그 대신 데이터의 읽기 속도를 높인다.
  - 데이터의 저장 속도를 어디까지 희생할 수 있느냐 vs 읽기 속도를 얼마나 더 빠르게 만들어야 하느냐


### 역할 별 구분 (저자는 key == index를 같은 의미로 사용)
- 프라이머리 키 (PK) 
  - 식별자라고도 부름 
  - null과 중복을 허용하지 않음 


- 보조 키(세컨더리 키)
  - PK를 제외한 나머지 인덱스는 모두 세컨더리 키로 분류 
  - 유니크 인덱스는 PK와 성격이 비슷하고, PK를 대체해서 사용할 수도 있다고 해서 "대체 키"라고도 함 
  - 별도로 분류하기도 하고, 세컨더리 인덱스로 분류하기도 함 

### 데이터 저장 방식(알고리즘) 별 구분 
- B-Tree
  - 가장 일반적으로 사용되는 인덱스 알고리즘 
  - 인덱스 칼럼 값 변형 없이 원래의 값을 이용해 인덱싱 
  - MySQL은 위치 기반 검색의 R-Tree 인덱스 알고리즘도 지원함 (B-Tree의 응용임)


- Hash
  - 칼럼의 값으로 해시값을 계산해서 인덱싱 
  - 매우 빠른 검색 지원 
  - 값을 변형해서 인덱싱하기 때문에 `Prefix`일치와 같이 값의 일부만 검색하거나 범위를 검색할 때는 사용할 수 없음 
  - 메모리 기반 데이터베이스에서 많이 사용 


### 중복 허용 여부로 분류
- 유니크 인덱스
- 유니크하지 않은 인덱스 


- Fractal-Tree, Merge-Tree...