# 유니크 인덱스
- 인덱스라기 보다 제약 조건에 가까움 
  - 테이블이나 인덱스에 같은 값이 2개 이상 저장될 수 없음을 의미 
- MySQL에서는 인덱스 없이 유니크 제약만 설정할 방법이 없음
  - null이 저장될 수 있음
  - null은 특정 값이 아니라 여러개 저장 가능 
- MySQL의 PK는 기본적으로 null을 허용하지 않는 유니크 속성이 자동 부여됨 
  - MyISAM, 메모리 테이블에서 PK는 null이 허용되지 않는 유니크 인덱스와 같음
  - InnoDB에서는 PK가 클러스터링 키의 역할도 하기 때문에 유니크 인덱스와는 근본적으로 다름 

<br/><br/>
## 유니크 인덱스 vs 일반 세컨더리 인덱스 
- 인덱스 구조상 아무런 차이점이 없음 

### 인덱스 읽기
- 인덱스 자체에서는 성능상 차이가 없음 
  - 유니크 인덱스 -> 컬럼값을 1번만 비교
  - 세컨더리 인덱스 -> 컬럼값을 여러번 비교 
  - 이는 CPU에서 비교하므로 성능 상 영향이 거의 없음


- 유니크 하지 않은 세컨더리 인덱스는 **중복된 값이 허용되기 때문에 읽어야 할 레코드가 많아서 느린 것**이다.
  - 인덱스 자체의 특성 때문에 느린게 아님 
  - 즉, 레코드 1건을 읽는 데 0.1초가 걸리고 2건을 읽을 때 0.2초가 걸린다고 할 때, 후자를 느리게 처리됐다고 할 수는 없다는 뜻이다.


### 인덱스 쓰기
- 유니크 인덱스의 키 값을 쓸 때는 중복된 값이 있는지 없는지 체크하는 과정이 한 단계 더 필요하다.
  - 유니크하지 않은 세컨더리 인덱스의 쓰기보다 느리다.
- MySQL에서는 유니크 인덱스에서 중복된 값을 체크할 떄는 읽기 잠금을 사용하고, 쓰기를 할 때는 쓰기 잠금을 사용한다.
  - 이 과정에서 **데드락이 아주 빈번히 발생**한다.
- InnoDB 스토리지 엔진에는 인덱스 키의 저장을 버퍼링하기 위해 체인지 버퍼가 사용됨 
  - 인덱스 저장 및 변경 작업이 상당히 빨리 처리되나, 안타깝게도 유니크 인덱스는 중복 체크를 해야하기 때문에 작업 자체를 **버퍼링 할 수 없음**
- 결론적으로, 유니크 인덱스는 일반 세컨더리 인덱스보다 변경 작업이 더 느림 


<br/><br/>
## 유니크 인덱스 사용 시 주의사항
- 꼭 필요하면 유니크 인덱스를 생성하는 것은 당연하나, **성능이 더 좋아질 것으로 생각하고 불필요하게 유니크 인덱스를 생성**하지는 않는 것이 좋다.
- 유니크 인덱스와 세컨더리 인덱스를 중복으로 만들지는 말자. 
  - 즉, 불필요한 중복 인덱스를 생성하지 않도록 주의하자. 

### 결론적으로
유일성이 꼭 보장돼야 하는 칼럼에 대해서는 유니크 인덱스를 생성하되, 꼭 필요하지 않다면 유니크 인덱스보다는 유니크하지 않은 세컨더리 인덱스를 생성하는 방법도 고려해보자.


