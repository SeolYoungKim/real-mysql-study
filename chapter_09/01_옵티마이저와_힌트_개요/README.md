> _MySQl 서버로 요청된 쿼리는 결과는 동일하지만 **내부적으로 결과를 만들어내는 방법은 매우 다양하다**_

- 다양한 방법들 중에서, 어떤 방법이 최적이고 최소의 비용이 소모될지 결정해야 함
- MySQL은 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장돼 있는지 통계 정보를 참조함 
  - 그러한 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업이 필요 
  - 옵티마이저가 이러한 기능 담당
  - `explain`명령어로 쿼리 실행 계획 확인 가능 
  
# 개요 
- 쿼리의 실행 계획을수립하는 옵티마이저는 가장 복잡한 부분이다.

## 쿼리 실행 절차 
MySQL 서버에서 쿼리가 실행되는 과정 
1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수분으로 분리(파스 트리)
2. SQL의 파싱 정보(파스 트리)를 확인하면서, 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택 
3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져옴 

- 첫 번째 단계 : "파싱"이라고 함 
  - MySQL 서버의 "SQL 파서"라는 모듈로 처리 
  - SQL문장이 문법적으로 잘못됐을 경우, 이 단계에서 걸러짐 
  - 해당 단계에서 "SQL 파스 트리"가 만들어짐
  - SQL 문장 그 자체가 아닌, SQL 파스 트리를 이용해 쿼리 실행 


- 두 번째 단계 : 파스 트리를 참조하며 아래의 내용 처리. (최적화 및 실행 계획 수립)
  - "옵티마이저"가 처리
  - 불필요한 조건 제거
  - 복잡한 연산 단순화
  - 여러 테이블의 조인이 있는 경우, 어떤 순서로 테이블을 읽을지 결정 
  - 각 테이블에서 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정 
  - 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
  - 두 번째 단계가 완료될 경우 쿼리의 "실행 계획"이 생성됨 


- 세 번째 단계 : 수립된 "실행 계획"대로 스토리지 엔진에 레코드를 읽어오도록 요청 
- MySQL 엔진에서는 스토리지 엔진으로 부터 받은 레코드를 조인하거나 정렬하는 작업 수행 

> - 첫 번째 단계와 두 번째 단계는 거의 MySQL 엔진에서 처리
> - 세 번째 단계는 MySQL 엔진과 스토리지 엔진이 동시에 참여해서 처리 


<br/><br/>
## 옵티마이저의 종류 
- 데이터베이스 서버에서 두뇌와 같은 역할을 담당함 
  - 많은 DBMS가 선택하고 있는 비용 기반 최적화(CBO, Cost-based optimizer)
  - 초기 버전 오라클에서 많이 사용했던 규칙 기반 최적화(RBO, Rule-based optimizer)

### 규칙 기반 최적화
- 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않음 
- 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립 
- 통계 정보(테이블의 레코드 건수, 컬럼값 분포도)를 조사하지 않은 채 실행 계획 수립 -> 같은 쿼리에 대해서는 거의 항상 같은 실행 방법을 생성함 
- 사용자 데이터는 분포도가 매우 다양하다
  - 규칙 기반 최적화는 오래 전 부터 많은 DBMS에서 거의 사용되지 않음 

### 비용 기반 최적화 
- 쿼리를 처리하기 위한 여러 가지 가능한 방법을 생성 
- 각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출 
- 산출된 실행 방법별로 비용이 최소로 소요되는 처리 방식 선택 -> 최종적으로 쿼리 실행 

